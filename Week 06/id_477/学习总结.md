
# Trie word list 2 时间复杂度

1. 遍历数组并生成trie N*k
2. 查找 m * m * k  

# 双向BFS

算法与之前描述的标准广搜方法相类似。

1. 从两个节点同时开始搜索
2. 两个访问数组，分别记录从两端的起点是否已经访问了该节点
3. 如果一个节点被两个搜索同时访问，就结束搜索过程，双向搜索的结束条件是找到一个单词被两边搜索都访问过
4. 返回中间节点在两边的层次之和

```
def BFS(graph, start, end):
    begin_set, end_set, visited = set(), set(), set()
    begin_set.add([start])
    end_set.add([end])

    while begin_set and end_set:
		# 交换，queue_begin为小者
		if len(queue_begin) > len(quene_end):
			queue_begin, quene_end = quene_end, queue_begin

		node = begin_set.pop()
        process(node)
		if node in end_set:
			return  
        visited.add(node)
        nodes = generate_related_nodes(node)
        begin_set = nodes

        # other processing work
        ...
```

# 并查集

```
def init(p): 
	# for i = 0 .. n: p[i] = i; 
	p = [i for i in range(n)] 
 
def union(self, p, i, j): 
	p1 = self.parent(p, i) 
	p2 = self.parent(p, j) 
	p[p1] = p2 
 
def parent(self, p, i): 
	root = i 
	while p[root] != root: 
		root = p[root] 
	while p[i] != i: # 路径压缩 ?
		x = i; i = p[i]; p[x] = root 
	return root
```
