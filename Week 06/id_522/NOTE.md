# NOTE

周一，看了一下，视频，过了一遍，好在老师，没有让实现AVL 和 红黑树。 否则，哭了。
红黑树就是2-3树，我还没学会。

提出两个问题，关于python 的，如果有能力的同学，给予指导？？？

1、 Trie 树，，python 是否有标准的库，我们可以调用别人写好的库，就像，random 库，time 库，collections 库？
2、 并差集，python 是否有标准的库？或者叫做，最佳实践代码？


周二看第二遍，准备做题。
--------------------------------时间复杂度
关于单词搜索2， 暴力搜索的时间复杂度为 N*m*m *4^k  , 其中N 是 单词的个数，
m 是搜索二维数组的边长，4 表示4个方向上搜索，k 表示最长的单词长度。

如果，使用trie 树，来解决。
首先，把单词都写入trie 树 ，需要O(N*k)
for for 两次循环 。

而后就是分析那个二维数组的遍历，虽然可以先进行一次O（m*m） 搜索，只要不在trie 中，
就记录下来，不搜了。
但最坏情况下，整个DFS 都搜索完， O(m*m *4^k)

由于无法确定 N 到底多大 ，所以，时间复杂度为 O( MAX (N*k , m*m *4^k))

这里假设k 为 7 ，那么 4^k 已经为16384 ， m假设为5  ，m*m *4^k=409600

N 大约需要超过58514 。

结论，基本用了trie 后，时间复杂度为 O(m*m *4^k)  ,对比暴力，差异明显。

-------------------------------------------双向BFS
关于双向BFS , 模板的理解，如下：

首先，就是想象在池塘的两端，同时扔进去一个大石头，波纹扩散，相遇。最短路径。



step =1
start={start_word}
end={end_word}
wordlist={wordlist}

while start:
    step +=1
    next_start=set()

    # 循环遍历
    for word in start:
        #建立新word
        new_word = ??
        #终止条件，找到了
        if new_word in end:return step
        else：
            #向next_start 集合中，放入需要下一步处理的数据
            #可能需要循环多次
            someword=??

            next_start.add(someword)

            wordlist.remove(someword)  #变更

    start=next_start

    if len(start)>len(end): start,end=end,start #switch 精髓所在
#没有相交
return 0


这几天，随着做题的数量有所上升，感觉到了，升维和降维的好处；
看了启发式搜索，老师讲的很好，就是关注估价函数怎么写，曼哈顿距离，在二维坐标中，就是速度比欧拉要快。

再有，优先级队列来了，这就是基础数据结构的力量。
最后，花花酱，告诉我们最好的是双向A* 搜索，
暂时先写BFS 吧，把 双向BFS 写好了再说吧。
这里面最牛的思想就是，对比两个集合，头和尾，哪个元素少，就让谁当头（交换位置）。
记忆心法就是侦察兵走最前面，即使被抓了，身上带的武器少，损失很小。代价很小，这里就是时间复杂度小。

明显感觉难度较大。现在是周四上午了，估计最多还能做几道题。

关于数独的，提前扫描一遍，是个不错的方法。视频看了两遍了，继续。
老师说的很对，过遍数，你会发现，理解一点一点上来了。


整体感觉，DFS ，就是傻搜，改进难；而BFS ,在理解了剪枝，双向搜索，优先级搜索后，改进了。

而启发式搜索，按照优先级出队，其实就是升维了。双向也是升维了，

所以，链表+记忆化索引=跳表
优先级队列+BFS =启发式搜索 。

算法就是老师说的，if else ，for  while ，函数调用（递归调用）。
